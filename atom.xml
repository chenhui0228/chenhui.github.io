<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈辉的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://202.104.112.179:8085/"/>
  <updated>2017-08-10T11:08:33.255Z</updated>
  <id>http://202.104.112.179:8085/</id>
  
  <author>
    <name>陈辉</name>
    <email>chenhui0228@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue.js学习-搭建一个简单的demo</title>
    <link href="http://202.104.112.179:8085/2017/08/10/vuejs-demo/"/>
    <id>http://202.104.112.179:8085/2017/08/10/vuejs-demo/</id>
    <published>2017-08-10T02:17:19.000Z</published>
    <updated>2017-08-10T11:08:33.255Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><strong>原创申明</strong>：本文为博主原创，转载请注明出处！</p>
<hr>
<p>这里主要记录vue.js+webpack在一个简单实例中的使用过程</p>
<blockquote>
<p><strong>说明</strong>：本次搭建基于Win 7平台</p>
</blockquote>
<h3 id="Node-js-安装"><a href="#Node-js-安装" class="headerlink" title="Node.js 安装"></a>Node.js 安装</h3><p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="external">官网</a>提供了支持多种平台的的LTS版本下载，我们根据需要来进行下载安装。对于Windows平台提供了.mis和.zip(二进制)两种选择，我们可以根据自己需要任选一种安装。具体安装过程就不详说。</p>
<blockquote>
<p><strong>注意</strong>：为了使用方便，我们需要检测PATH环境变量是否配置了Node.js。点击开始=》运行=》输入“cmd”=》输入命令“path”（我们也可以直接使用命令win+R输入“cmd”=》输入命令“path”），输出如下结果：</p>
<pre><code>C:\Users\01107267&gt;path
PATH=C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;
D:\Program Files\java\jdk1.8.0-windows-x64\bin;D:\Program Files\java\jdk1.8.0-windows-x64\jre\bin;
D:\Program Files\TortoiseSVN\bin;D:\Program Files\apache-maven-3.3.9\bin;D:\Program Files\gradle-2.2.1\BIN;
D:\Python27\Scripts;D:\Python27\;D:\Program Files\nodejs\;D:\Program Files\nodejs\node_global;
</code></pre><p>我们看到环境变量中已经包含了D:\Program Files\nodejs，我们可以检查一下Node.js版本</p>
<pre><code>C:\Users\01107267&gt;node --version
v6.9.4
</code></pre><p>我们可以看到有这样一个路径在Node.js目录下还有一个npm，这是Nodejs中的包管理工具，它是随Nodejs一起安装的</p>
<pre><code>C:\Users\01107267&gt;npm -v
3.10.10 
</code></pre><p>这里需要说明的是可以看到还有一个路径D:\Program Files\nodejs\node_global;这个路径是说将npm安装时指定全局安装的包放在该路径下，比如后面我们会用的webpack，我们可以去到该目录看一下</p>
<pre><code>D:\Program Files&gt;cd nodejs

D:\Program Files\nodejs&gt;dir
 驱动器 D 中的卷没有标签。
 卷的序列号是 0005-FCB7

 D:\Program Files\nodejs 的目录

2017/03/12  11:52&lt;DIR .
2017/03/12  11:52&lt;DIR ..
2017/01/05  21:0018,513,048 node.exe
2016/12/22  18:01   702 nodevars.bat
2017/08/07  19:29&lt;DIR node_cache
2017/01/05  20:46 8,997 node_etw_provider.man
2017/08/08  09:49&lt;DIR node_global
2017/01/16  10:57&lt;DIR node_modules
2016/12/22  18:01 4,974 node_perfctr_provider.man
2016/11/16  19:45   867 npm
2016/11/16  19:45   483 npm.cmd
   6 个文件 18,529,071 字节
   5 个目录 146,669,424,640 可用字节

D:\Program Files\nodejs&gt;cd node_global

D:\Program Files\nodejs\node_global&gt;dir
 驱动器 D 中的卷没有标签。
 卷的序列号是 0005-FCB7

 D:\Program Files\nodejs\node_global 的目录

2017/08/08  09:49&lt;DIR .
2017/08/08  09:49&lt;DIR ..
2017/03/12  11:56&lt;DIR etc
2017/08/08  09:49&lt;DIR node_modules
2017/08/07  17:46   321 vue
2017/08/07  17:46   333 vue-build
2017/08/07  17:46   210 vue-build.cmd
2017/08/07  17:46   331 vue-init
2017/08/07  17:46   208 vue-init.cmd
2017/08/07  17:46   331 vue-list
2017/08/07  17:46   208 vue-list.cmd
2017/08/07  17:46   198 vue.cmd
2017/08/08  09:49   335 webpack
2017/08/08  09:49   379 webpack-dev-server
2017/08/08  09:49   256 webpack-dev-server.cmd
2017/08/08  09:49   212 webpack.cmd
  12 个文件  3,322 字节
   4 个目录 146,669,424,640 可用字节

D:\Program Files\nodejs\node_global&gt;
</code></pre></blockquote>
<h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>新建一个项目文件夹，名为vuedemo</p>
<pre><code>E:\IDC\Workspace&gt;md vuedemo

E:\IDC\Workspace&gt;cd vuedemo

E:\IDC\Workspace\vuedemo&gt;
</code></pre><p>初始化项目，生成package.json文件</p>
<pre><code>E:\IDC\Workspace\vuedemo&gt;npm init -y
Wrote to E:\IDC\Workspace\vuedemo\package.json:

{
  &quot;name&quot;: &quot;vuedemo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}



E:\IDC\Workspace\vuedemo&gt;dir
 驱动器 E 中的卷没有标签。
 卷的序列号是 000D-8BC6

 E:\IDC\Workspace\vuedemo 的目录

2017/08/10  09:59&lt;DIR&gt;  .
2017/08/10  09:59&lt;DIR&gt;  ..
2017/08/10  09:59   221 package.json
   1 个文件221 字节
   2 个目录 91,132,411,904 可用字节
</code></pre><h4 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h4><p>在使用npm安装依赖之前，我先解释几个参数。npm安装分为全局安装和和本地安装。如：</p>
<pre><code>npm install express        # 本地安装
npm install express -g    # 全局安装
</code></pre><blockquote>
<p><strong>说明</strong>：</p>
<p>本地安装</p>
<blockquote>
<ul>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ul>
</blockquote>
<p>全局安装</p>
<blockquote>
<ul>
<li>将安装包放在 .\/node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以直接在命令行里使用。</li>
</ul>
</blockquote>
<p>如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。</p>
</blockquote>
<p>另外，npm install在安装npm包时，有两种命令可以把他们的信息写入package.json文件，一个是npm install –save另一个是 npm install –save-dev，他们表面上的区别是–save 会把依赖包名称添加到 package.json 文件 dependencies 键下，–save-dev 则添加到 package.json 文件 devDependencies 键下，–save-dev 是你开发时候依赖的东西，–save 是你发布之后还依赖的东西。</p>
<h5 id="安装vue及相关组件"><a href="#安装vue及相关组件" class="headerlink" title="安装vue及相关组件"></a>安装vue及相关组件</h5><p>安装<a href="https://cn.vuejs.org/" target="_blank" rel="external">vue.js</a>，默认安装最新的版本</p>
<pre><code>nmp install --save vue
</code></pre><p>安装路由组件vue-router.js</p>
<pre><code>nmp install --save vue-router
</code></pre><blockquote>
<p><strong>拓展</strong>：在一个项目中通常还需要用到的组件<a href="https://github.com/pagekit/vue-resource" target="_blank" rel="external">vue-resource</a>进行HTTP异步请求提交，还可以使用<a href="http://element.eleme.io/#/zh-CN/component/installation" target="_blank" rel="external">element-ui</a>提供的各种前端组件帮助我们快速完成开发。</p>
</blockquote>
<h5 id="安装webpack及相关组件"><a href="#安装webpack及相关组件" class="headerlink" title="安装webpack及相关组件"></a>安装webpack及相关组件</h5><p>全局和本地安装<a href="https://webpack.github.io" target="_blank" rel="external">webpack</a>，以及Nodejs.js解释服务器webpack-dev-server</p>
<pre><code>npm install webpack webpack-dev-server -g                    #全局安装
npm install --save-dev webpack webpack-dev-server            #本地安装
</code></pre><h5 id="安装其他有用的组件"><a href="#安装其他有用的组件" class="headerlink" title="安装其他有用的组件"></a>安装其他有用的组件</h5><p>安装babel，其作用是将ES6的语法编译成浏览器认识的语法ES5</p>
<pre><code>npm install --save-dev babel-core babel-loader babel-preset-es2015
</code></pre><p>安装vue解析组件，解析.vue后缀文件</p>
<pre><code>npm install --save-dev vue-loader vue-template-compiler
</code></pre><p>安装css解析组件</p>
<pre><code>npm install --save-dev css-loader style-loader
</code></pre><blockquote>
<p><strong>拓展</strong>：css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。</p>
</blockquote>
<p>安装url-loader，file-loader打包文件和图片</p>
<pre><code>npm install --save-dev url-loader file-loader
</code></pre><p>查看一下package.json文件的内容</p>
<pre><code>E:\IDC\Workspace\vuedemo&gt;type package.json
{
  &quot;name&quot;: &quot;vuedemo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;vue&quot;: &quot;^2.4.2&quot;,
    &quot;vue-router&quot;: &quot;^2.7.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.25.0&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.4&quot;,
    &quot;file-loader&quot;: &quot;^0.11.2&quot;,
    &quot;style-loader&quot;: &quot;^0.18.2&quot;,
    &quot;url-loader&quot;: &quot;^0.5.9&quot;,
    &quot;vue-loader&quot;: &quot;^13.0.4&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.4.2&quot;,
    &quot;webpack&quot;: &quot;^3.5.2&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.7.1&quot;
  }
}
</code></pre><h4 id="编辑项目目录和添加代码"><a href="#编辑项目目录和添加代码" class="headerlink" title="编辑项目目录和添加代码"></a>编辑项目目录和添加代码</h4><p>查看当前目录</p>
<pre><code>E:\IDC\Workspace\vuedemo&gt;tree
E:.
├─ dist
├─ node_modules
│   ├─ .bin
│   └─ ...
├─ src
│   ├─ assets
│   │   ├─ imgs
│   │   │   └─ logo.png
│   │   └─ styles
│   │       └─ base.css
│   ├─ components
│   │      └─ header.vue
│   ├─ views
│   │   ├─ about.vue
│   │   └─ home.vue
│   ├─ App.vue
│   ├─ main.js
│   └─ routes.js
├─ index.html  
├─ package.json    
└─ webpack.config.js    
</code></pre><h5 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h5><p>//dist文件是后面执行webpack指令生产的，不用管；</p>
<p>//webpack.config.js 配置文件，本身也是一个标准的Commonjs规范的模块；</p>
<p>//routes.js文件放路由配置文件；</p>
<p>//index.html首页入口文件</p>
<p>//App.vue是项目入口文件。</p>
<p>//main.js这是项目的核心文件。全局的配置都在这个文件里面配置。</p>
<p>//components目录里面放了公共组件header文件。</p>
<p>//views文件放详情页面；</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><h6 id="根目录代码"><a href="#根目录代码" class="headerlink" title="根目录代码"></a>根目录代码</h6><p>这里主要是编写webpack.config.js配置文件</p>
<pre><code>/**
 * Created by 01107267 on 2017/8/7.
 */
var path = require(&apos;path&apos;)
var webpack = require(&apos;webpack&apos;)

module.exports = {
    entry: &apos;./src/main.js&apos;,//也可以是数组，对象
    output: {
        path: path.resolve(__dirname, &apos;./dist&apos;),//webpack 构建后的结果存在此位置
        publicPath: &apos;/dist/&apos;,   //许多Webpack的插件用于在生产模式和开发模式下下更新内嵌到css、html，img文件里的url值
        filename: &apos;build.js&apos;
    },
    module: {
        rules: [
            {
                test: /\.vue$/, //一个匹配loaders所处理的文件的拓展名的正则表达式（必须）
                loader: &apos;vue-loader&apos;, //loader的名称（必须）
                options: {
                    loaders: {
                    }
                    //other vue-oader options go here
                }
            },
            {
                test: /\.(png|jpe?g|gif|svg)(\?\S*)?$/,
                loader: &apos;file-loader&apos;,
                query: {
                    name: &apos;[name].[ext]?[hash]&apos;
                }
            },
            {
                test: /\.js$/,
                loader: &apos;babel-loader&apos;,
                exclude: /node_modules/
            },
            // self define
            {
                test: /\.css$/,
                loader: &quot;style-loader!css-loader&quot;
            }
            ,
            {
                test: /\.scss$/,
                loader: &quot;style-loader!css-loader!sass-loader!&quot;
            },
            {
                test: /\.(eot|svg|ttf|woff|woff2)(\?\S*)?$/,
                loader: &apos;file-loader&apos;
            }
          ]
    },
    resolve: {
        alias: {
            &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;
        }
    },
    devServer: {//webpack-dev-server配置
        historyApiFallback: true,//不跳转
        noInfo: true,
        inline: true//实时刷新
    },
    performance: {
        hints: false
    },
    devtool: &apos;#eval-source-map&apos;
}

if (process.env.NODE_ENV === &apos;production&apos;) {
    module.exports.devtool = &apos;#source-map&apos;
    // http://vue-loader.vuejs.org/en/workflow/production.html
    module.exports.plugins = (module.exports.plugins || []).concat([
        new webpack.DefinePlugin({
            &apos;process.env&apos;: {
                NODE_ENV: &apos;&quot;production&quot;&apos;
            }
        }),
        new webpack.optimize.UglifyJsPlugin({
            sourceMap: true,
            compress: {
                warnings: false
            }
        }),
        new webpack.LoaderOptionsPlugin({
            minimize: true
        })
    ])
}
</code></pre><blockquote>
<p><strong>注释</strong>：<br>test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须）<br>loader：loader的名称（必须）<br>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）</p>
</blockquote>
<p>编写routes.js文件</p>
<pre><code>// 引用模板
import Vue from &apos;vue&apos;;
import Router from &apos;vue-router&apos;;
import indexPage from &apos;./components/header.vue&apos;
import homePage from &apos;./views/home.vue&apos;
import aboutPage from &apos;./views/about.vue&apos;

Vue.use(Router)

export default new Router({
    routes:[
        {
            path:&apos;/&apos;,
            component:homePage
        },
        {
            path:&apos;/about&apos;,
            component:aboutPage
        }
    ]
})
</code></pre><p>编写index.html文件</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;appIndex&quot;&gt;

    &lt;/div&gt;
    &lt;script src=&quot;./dist/build.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>编写App.vue文件</p>
<pre><code>&lt;!--App.vue是项目入口文件。--&gt;
&lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;header-tab&gt;&lt;/header-tab&gt;
        &lt;h2&gt;{{msg}}&lt;/h2&gt;
        &lt;div class=&quot;nav-box&quot;&gt;
            &lt;p class=&quot;nav-list&quot;&gt;
                &lt;router-link class=&quot;nav-item&quot; to=&quot;/&quot;&gt;首页&lt;/router-link&gt;
                &lt;router-link class=&quot;nav-item&quot; to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;
            &lt;/p&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;router-view&gt;&lt;/router-view&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import HeaderTab from &apos;./components/header.vue&apos;;
export default {
  name: &apos;app&apos;,
  data () {
    return {
      msg: &apos;Welcome to Your Vue.js App&apos;
    }
  },
  components:{
    HeaderTab
  }
}
&lt;/script&gt;

&lt;style type=&quot;text/css&quot;&gt;
    h2{
        color:#ff0000;
    }
    #app {
        text-align: center;
        color: #2c3e50;
        margin-top: 60px;
    }
    h1, h2 {
        font-weight: normal;
    }
    ul {
        list-style-type: none;
        padding: 0;
    }
    li {
        text-align: left;
        margin: 0 10px;
    }
    a {
        color: #42b983;
    }
&lt;/style&gt;
</code></pre><p>编写main.js文件</p>
<pre><code>//main.js这是项目的核心文件。全局的配置都在这个文件里面配置
import Vue from &apos;vue&apos;
import App from &apos;./App.vue&apos;
import router from &apos;./routes.js&apos;

import &apos;./assets/styles/base.css&apos;
Vue.config.debug = true;//开启错误提示

new Vue({
        router,
        el: &apos;#appIndex&apos;,
        render: h =&gt; h(App)
})
</code></pre><h6 id="components组件目录代码"><a href="#components组件目录代码" class="headerlink" title="components组件目录代码"></a>components组件目录代码</h6><p>编写header.vue文件</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;共同header&lt;/h1&gt;
        &lt;img src=&quot;../assets/imgs/logo.png&quot;&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><h6 id="views目录代码"><a href="#views目录代码" class="headerlink" title="views目录代码"></a>views目录代码</h6><p>编写about.vue文件</p>
<pre><code>//about.vue
&lt;template&gt;
    &lt;div&gt;about&lt;/div&gt;
&lt;/template&gt;
</code></pre><p>编写home.vue文件</p>
<pre><code>//index.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;ol&gt;
            &lt;li v-for=&quot;todo in todos&quot;&gt;
                {{ todo.text }}
            &lt;/li&gt;
        &lt;/ol&gt;
        &lt;button @click=&quot;eClick()&quot;&gt;事件&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;indexP&apos;,
  data () {
    return {
       todos: [
          { text: &apos;Learn JavaScript&apos; },
          { text: &apos;Learn Vue&apos; },
          { text: &apos;Build something awesome&apos; }
        ]
    }
  },
  methods:{
    eClick(){
        console.log(9999);
    }
  }
}
&lt;/script&gt;
</code></pre><h6 id="style目录代码"><a href="#style目录代码" class="headerlink" title="style目录代码"></a>style目录代码</h6><p>编写base.css文件</p>
<pre><code>h1{
    color: #999;
}
</code></pre><h4 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h4><p>构建打包</p>
<pre><code>webpack
</code></pre><img src="/2017/08/10/vuejs-demo/webpack.png" alt="webpack.png" title="">
<p>执行webpack-dev-server</p>
<pre><code>webpack-dev-server
</code></pre><img src="/2017/08/10/vuejs-demo/webpack-dev-server.png" alt="webpack-dev-server.png" title="">
<p>页面效果</p>
<img src="/2017/08/10/vuejs-demo/index.jpg" alt="index.jpg" title="">
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;原创申明&lt;/strong&gt;：本文为博主原创，转载请注明出处！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这里主要记录vue.js+webpack在一个简单实例中的使用过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：本次搭建基于W
    
    </summary>
    
      <category term="Web前端技术" scheme="http://202.104.112.179:8085/categories/Web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="vue" scheme="http://202.104.112.179:8085/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记（一）</title>
    <link href="http://202.104.112.179:8085/2017/08/04/python-learning-01/"/>
    <id>http://202.104.112.179:8085/2017/08/04/python-learning-01/</id>
    <published>2017-08-04T02:27:01.000Z</published>
    <updated>2017-08-10T11:14:00.688Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><strong>原创申明</strong>：本文为博主原创，转载请注明出处！</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;原创申明&lt;/strong&gt;：本文为博主原创，转载请注明出处！&lt;/p&gt;
&lt;hr&gt;

    
    </summary>
    
      <category term="python" scheme="http://202.104.112.179:8085/categories/python/"/>
    
    
      <category term="python" scheme="http://202.104.112.179:8085/tags/python/"/>
    
      <category term="编程学习" scheme="http://202.104.112.179:8085/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>linux常用操作总结</title>
    <link href="http://202.104.112.179:8085/2017/08/01/linux-ops/"/>
    <id>http://202.104.112.179:8085/2017/08/01/linux-ops/</id>
    <published>2017-08-01T06:17:19.000Z</published>
    <updated>2017-08-10T11:13:11.900Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><strong>原创申明</strong>：本文为博主原创，转载请注明出处！</p>
<hr>
<h4 id="查看当前文件夹大小"><a href="#查看当前文件夹大小" class="headerlink" title="查看当前文件夹大小"></a>查看当前文件夹大小</h4><pre><code>du -sh *
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;原创申明&lt;/strong&gt;：本文为博主原创，转载请注明出处！&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;查看当前文件夹大小&quot;&gt;&lt;a href=&quot;#查看当前文件夹大小&quot; class=&quot;headerlink&quot; title=&quot;查看当前文件夹大小&quot;&gt;&lt;/a&gt;查看当
    
    </summary>
    
      <category term="linux" scheme="http://202.104.112.179:8085/categories/linux/"/>
    
    
      <category term="linux" scheme="http://202.104.112.179:8085/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>CEPH运维之安装部署（luminous）</title>
    <link href="http://202.104.112.179:8085/2017/08/01/ceph-ops/"/>
    <id>http://202.104.112.179:8085/2017/08/01/ceph-ops/</id>
    <published>2017-08-01T06:09:41.000Z</published>
    <updated>2017-08-10T11:11:47.796Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><strong>原创申明</strong>：本文为博主原创，转载请注明出处！    </p>
<hr>
<p>这篇文档主要介绍ceph的搭建过程。</p>
<h3 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h3><p>服务器规划及配置，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">hostname</th>
<th style="text-align:left">public ip</th>
<th style="text-align:left">cluster ip</th>
<th style="text-align:left">节点说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ch-osd-1</td>
<td style="text-align:left">172.16.30.73</td>
<td style="text-align:left">172.16.31.73</td>
<td style="text-align:left">osd节点</td>
</tr>
<tr>
<td style="text-align:left">ch-osd-2</td>
<td style="text-align:left">172.16.30.72</td>
<td style="text-align:left">172.16.31.72</td>
<td style="text-align:left">osd节点</td>
</tr>
<tr>
<td style="text-align:left">ch-osd-3</td>
<td style="text-align:left">172.16.30.75</td>
<td style="text-align:left">172.16.31.75</td>
<td style="text-align:left">osd节点</td>
</tr>
<tr>
<td style="text-align:left">ch-osd-4</td>
<td style="text-align:left">172.16.30.77</td>
<td style="text-align:left">172.16.31.77</td>
<td style="text-align:left">osd节点</td>
</tr>
<tr>
<td style="text-align:left">ch-mon-1</td>
<td style="text-align:left">172.16.30.78</td>
<td style="text-align:left">172.16.31.78</td>
<td style="text-align:left">mon+rgw+manger节点</td>
</tr>
<tr>
<td style="text-align:left">ch-mon-2</td>
<td style="text-align:left">172.16.30.79</td>
<td style="text-align:left">172.16.31.79</td>
<td style="text-align:left">mon+rgw节点</td>
</tr>
<tr>
<td style="text-align:left">ch-mon-3</td>
<td style="text-align:left">172.16.30.80</td>
<td style="text-align:left">172.16.31.80</td>
<td style="text-align:left">mon+rgw节点</td>
</tr>
</tbody>
</table>
<ul>
<li>操作系统：centos release 7.2</li>
<li>CPU：OSD节点为Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz * 48 ，MON节点为Intel(R) Xeon(R) CPU E5-2650 0 @ 2.00GHz * 32；</li>
<li>内存大小：OSD 为256GB； MON为64GB</li>
<li>数据硬盘配置（不含系统盘）：OSD 为1.2TB SAS * 3和480G SSD * 1，其中SSD不是必要的，我们这里主要存放journal，MON单独部署可以不需要数据盘</li>
<li>网络配置：public 网络和 cluster 均为万兆光纤</li>
<li>每台服务器第1，2块磁盘做RAID1；其余磁盘做RAID0</li>
<li>ch-mon-1节点作为管理节点，部署ceph-deploy</li>
<li>Ceph版本：目前最新版 v12.1.2</li>
<li>ceph-deploy版本：1.5.38</li>
<li>这里使用root用户安装，如果不是root用户，应该拥有root权限</li>
</ul>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="基础环境检查"><a href="#基础环境检查" class="headerlink" title="基础环境检查"></a>基础环境检查</h4><ol>
<li>网络连接正常（方法略）</li>
<li>ntp服务正常（方法略）</li>
<li>集群服务器时间，时区一致（方法略）</li>
<li>防火墙策略，开端口6789，6800：7300</li>
<li>SELINUX设置为Permissive或者禁掉</li>
<li>磁盘阵列检查</li>
</ol>
<p>首先需要在存储节点安装Megacli，下载RPM包，如MegaCli-8.07.14-1.noarch.rpm，安装命令如下：</p>
<pre><code>rpm -ivh MegaCli-8.07.14-1.noarch.rpm
</code></pre><p>使用磁盘阵列检查工具Megacli进行相关检查，查看是否满足需要的配置策略。</p>
<pre><code>/opt/MegaRAID/MegaCli64 -LDGetProp -Cache -LALL -aALL
</code></pre><p>一般情况可在安装操作系统前对各硬盘做好磁盘阵列，不同厂商的设备磁盘阵列配置略有不同，这里不做详述。如果没做磁盘阵列，这里需要做磁盘阵列，使用MegaCli来对磁盘做日常管理。</p>
<p>OSD数据盘做RAID0 ，并分别设置读、写、缓存策略，其中读策略为Read-Ahead；写策略为WriteBack，写入缓存直接返回；磁盘缓存Disk cache设置为disable；I/O策略为Direct请求不被系统Cache缓存。如磁盘编号为10 的物理磁盘组成一个RAID0</p>
<pre><code>/opt/MegaRAID/MegaCli64 -cfgldadd -r0 [32:10] WB RA RA -a0
</code></pre><p>或者</p>
<pre><code>/opt/MegaRAID/MegaCli64 -LDSetProp 10 WB -a0
/opt/MegaRAID/MegaCli64 -LDSetProp 10 RA -a0
/opt/MegaRAID/MegaCli64 -LDSetProp 10 RA -a0
</code></pre><p>SSD做日志盘做RAID0，读策略为Normal，不适用预读，写策略为Write Through直接写入磁盘；如果SSD有掉电保护，磁盘缓存Disk cache设置为Enable；I/O策略为Direct请求不被Cache缓存。</p>
<pre><code>/opt/MegaRAID/MegaCli64 -cfgldadd -r0 [32:13] WT NORA Direct -a0
</code></pre><p>Megacli更详细的使用，可以参考其他资料，如<a href="https://supportforums.cisco.com/document/62901/megacli-common-commands-and-procedures" target="_blank" rel="external">参考文档1</a>等</p>
<h4 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h4><h5 id="yum源配置"><a href="#yum源配置" class="headerlink" title="yum源配置"></a>yum源配置</h5><p>这里采用yum安装，我已经将CEPH二进制RPM包上传至YUM镜像，所以先配置CEPH可用的YUM源，包括CEPH本身和EPEL源，如下：</p>
<pre><code>[root@node-5 env-check-init]# cat /etc/yum.repos.d/CentOS.repo 
...
[CENTOS7-epel]
name=CENTOS7 epel resource
baseurl=http://yum17.int.sfdc.com.cn/epel7Server/$basearch
enabled=1
gpgcheck=0
gpgkey=http://yum17.int.sfdc.com.cn/epel7/$basearch/RPM-GPG-KEY-EPEL-7

[CENTOS7-ceph]
name=CENTOS7 ceph resource
baseurl=http://yum17.int.sfdc.com.cn/ceph/el7/$basearch
enabled=1
gpgcheck=0
gpgkey=http://yum17.int.sfdc.com.cn/ceph/el7/$basearch/RPM-GPG-KEY-EPEL-7
</code></pre><blockquote>
<p><strong>提示</strong>：如果你没有自己的YUM源可使用国内开源镜像，如<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="external">清华镜像</a>，<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="external">中科大镜像</a>，<a href="https://mirrors.aliyun.com/" target="_blank" rel="external">阿里镜像</a>等，也可以使用<a href="http://docs.ceph.com/docs/master/start/quick-start-preflight/#rhel-centos" target="_blank" rel="external">Ceph官方文档</a>给出的配置。</p>
</blockquote>
<h5 id="SSH互信"><a href="#SSH互信" class="headerlink" title="SSH互信"></a>SSH互信</h5><p>需要为管理节点和其他集群节点建立ssh互信，使管理节点可以免验证登录其他各节点</p>
<p>在管理节点生成ssh keys，命令如下：</p>
<pre><code>ssh-keygen
</code></pre><p>将管理节点的ssh key 拷贝到其它个节点：</p>
<pre><code>ssh-copy-id root@172.16.30.xxx
</code></pre><h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><h4 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a>软件包安装</h4><p>在管理节点安装ceph-deploy</p>
<pre><code>yum install ceph-deploy -y
</code></pre><p>安装Ceph，在各个节点执行命令</p>
<pre><code>yum install ceph -y
</code></pre><p>安装完后可以使用如下命令查看版本</p>
<pre><code>[root@ch-mon-1 ~]# ceph -v
ceph version 12.1.2 (b661348f156f148d764b998b65b90451f096cb27) luminous (rc)
</code></pre><p>同时，可以看到在/etc目录下新增了一个ceph目录。进入/etc/ceph目录</p>
<pre><code>cd /etc/ceph
</code></pre><h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><h5 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h5><p>准备3个Monitor节点</p>
<pre><code>ceph-deploy new ch-mon-1 ch-mon-2 ch-mon-3
</code></pre><p>执行完毕后再该目录下可以看到有如下文件</p>
<pre><code>[root@ch-mon-1 ceph]# pwd
/etc/ceph
[root@ch-mon-1 ceph]# ll
-rw-r--r-- 1 root root   805 Aug  3 13:44 ceph.conf
-rw-r--r-- 1 root root 33736 Aug  3 13:45 ceph-deploy-ceph.log
-rw------- 1 root root    73 Aug  3 13:43 ceph.mon.keyring
</code></pre><p>此时可以开始规划集群配置，如集群网络配置，我这里的配置如下：</p>
<p>默认配置</p>
<pre><code>[root@ch-mon-1 ceph]# cat ceph.conf 
[global]
fsid = 31fc3bef-d912-4d12-aa1e-130d3270d5db
mon_initial_members = ch-mon-1, ch-mon-2, ch-mon-3
mon_host = 172.16.30.78,172.16.30.79,172.16.30.80
auth_cluster_required = cephx
auth_service_required = cephx
auth_client_required = cephx
</code></pre><p>修改后</p>
<pre><code>[root@ch-mon-1 ceph]# cat ceph.conf 
[global]
fsid = 31fc3bef-d912-4d12-aa1e-130d3270d5db
mon_initial_members = ch-mon-1, ch-mon-2, ch-mon-3
mon_host = 172.16.30.78,172.16.30.79,172.16.30.80
auth_cluster_required = cephx
auth_service_required = cephx
auth_client_required = cephx

public_network = 172.16.30.0/24
cluster_network = 172.16.31.0/24
osd_pool_default_size = 3
osd_pool_default_min_size = 1
osd_pool_default_pg_num = 8
osd_pool_default_pgp_num = 8
osd_crush_chooseleaf_type = 1

[mon]
mon_clock_drift_allowed = 0.5

[osd]
osd_mkfs_type = xfs
osd_mkfs_options_xfs = -f
filestore_max_sync_interval = 5
filestore_min_sync_interval = 0.1
filestore_fd_cache_size = 655350
filestore_omap_header_cache_size = 655350
filestore_fd_cache_random = true
osd op threads = 8
osd disk threads = 4
filestore op threads = 8
max_open_files = 655350
</code></pre><h5 id="初始化Monitor"><a href="#初始化Monitor" class="headerlink" title="初始化Monitor"></a>初始化Monitor</h5><p>部署初始的monitors，并获得keys</p>
<pre><code>ceph-deploy mon create-initial
</code></pre><p>做完这一步，在当前目录下就会看到有如下的keyrings：</p>
<pre><code>[root@ch-mon-1 ceph]# ll
-rw------- 1 root root    71 Aug  3 13:45 ceph.bootstrap-mds.keyring
-rw------- 1 root root    71 Aug  3 13:45 ceph.bootstrap-mgr.keyring
-rw------- 1 root root    71 Aug  3 13:45 ceph.bootstrap-osd.keyring
-rw------- 1 root root    71 Aug  3 13:45 ceph.bootstrap-rgw.keyring
-rw------- 1 root root    63 Aug  3 13:45 ceph.client.admin.keyring
</code></pre><p>要在节点使用ceph命令行需要将ceph.client.admin.keyring放在需要的节点的/etc/ceph目录下。如这里希望在所有的节点使用命令行，可以通过如下命令将ceph.client.admin.keyring拷贝到各节点，当然也可以使用cp命令。</p>
<pre><code>ceph-deploy admin ch-mon-2 ch-mon-3 ch-osd-1 ch-osd-2 ch-osd-3 ch-osd-4
</code></pre><p>在L版本的Ceph中新增了manager daemon，如下命令部署一个Manager守护进程</p>
<pre><code>ceph-deploy mgr create ch-mon-1
</code></pre><h5 id="增加OSDs"><a href="#增加OSDs" class="headerlink" title="增加OSDs"></a>增加OSDs</h5><p>我们使用的版本后端存储默认使用bluestore</p>
<p>下面我们添加OSDs</p>
<pre><code>ceph-deploy osd create ch-osd-1:/dev/sdb ch-osd-1:/dev/sdc ch-osd-1:/dev/sdd ch-osd-2:/dev/sdb ch-osd-2:/dev/sdc ch-osd-2:/dev/sdd ch-osd-3:/dev/sdb ch-osd-3:/dev/sdc ch-osd-3:/dev/sdd ch-osd-4:/dev/sdb ch-osd-4:/dev/sdc ch-osd-4:/dev/sdd
</code></pre><blockquote>
<p><strong>提示</strong>：在早期的版本中，添加OSD分为prepare和activate两步，这里不详述</p>
</blockquote>
<p>等命令执行结束之后可以查看集群状态</p>
<pre><code>[root@ch-mon-1 ~]# ceph -s
  cluster:
    id:     31fc3bef-d912-4d12-aa1e-130d3270d5db
    health: HEALTH_OK

  services:
    mon: 3 daemons, quorum ch-mon-1,ch-mon-2,ch-mon-3
    mgr: ch-mon-1(active)
    osd: 12 osds: 12 up, 12 in

  data:
    pools:   0 pools, 0 pgs
    objects: 0 objects, 0 bytes
    usage:   12742 MB used, 13386 GB / 13398 GB avail
    pgs:
</code></pre><p>查看OSDs</p>
<pre><code>[root@ch-osd-1 ~]# ceph osd tree
ID CLASS WEIGHT   TYPE NAME         STATUS REWEIGHT PRI-AFF 
-1       13.08472 root default                              
-3        3.27118     host ch-osd-1                         
 0   hdd  1.09039         osd.0         up  1.00000 1.00000 
 1   hdd  1.09039         osd.1         up  1.00000 1.00000 
 2   hdd  1.09039         osd.2         up  1.00000 1.00000 
-5        3.27118     host ch-osd-2                         
 3   hdd  1.09039         osd.3         up  1.00000 1.00000 
 4   hdd  1.09039         osd.4         up  1.00000 1.00000 
 5   hdd  1.09039         osd.5         up  1.00000 1.00000 
-7        3.27118     host ch-osd-3                         
 6   hdd  1.09039         osd.6         up  1.00000 1.00000 
 7   hdd  1.09039         osd.7         up  1.00000 1.00000 
 8   hdd  1.09039         osd.8         up  1.00000 1.00000 
-9        3.27118     host ch-osd-4                         
 9   hdd  1.09039         osd.9         up  1.00000 1.00000 
10   hdd  1.09039         osd.10        up  1.00000 1.00000 
11   hdd  1.09039         osd.11        up  1.00000 1.00000 
</code></pre><p>至此，整个集群就搭建完毕。</p>
<p>通过对目前最新版本Ceph部署，可见比老版本比如生产上大量使用的Hammer版部署起来简单，当然这里没有太多的配置优化。</p>
<h3 id="常用运维"><a href="#常用运维" class="headerlink" title="常用运维"></a>常用运维</h3><h4 id="开启监控模块"><a href="#开启监控模块" class="headerlink" title="开启监控模块"></a>开启监控模块</h4><p>在配置文件/etc/ceph/ceph.conf中添加</p>
<pre><code>[mgr]
mgr modules = dashboard
</code></pre><p>或者</p>
<pre><code>ceph mgr module enable dashboard
</code></pre><p>设置dashboard的ip和端口</p>
<pre><code>ceph config-key put mgr/dashboard/server_addr 172.16.30.78
ceph config-key put mgr/dashboard/server_port 7000
</code></pre><p>重启mgr服务</p>
<pre><code>[root@ch-osd-1 ~]# systemctl restart ceph-mgr@ch-mon-1
</code></pre><h4 id="增加-删除-MONITORs"><a href="#增加-删除-MONITORs" class="headerlink" title="增加/删除 MONITORs"></a>增加/删除 MONITORs</h4><h5 id="增加MONITOR"><a href="#增加MONITOR" class="headerlink" title="增加MONITOR"></a>增加MONITOR</h5><h5 id="删除MONITOR"><a href="#删除MONITOR" class="headerlink" title="删除MONITOR"></a>删除MONITOR</h5><p>首先停需要删除的monitor守护进程，命令如下：</p>
<pre><code>service ceph -a stop mon.{mon-id}
#for example
service ceph -a stop mon.ch-mon-1
</code></pre><p>然后将monitor从集群删除</p>
<pre><code>ceph mon remove {mon-id}
#for example
ceph mon remove ch-mon-1
</code></pre><p>最后，删除ceph.conf中的该monitor配置</p>
<p>更详细的使用方法见<a href="http://docs.ceph.com/docs/master/rados/operations/add-or-rm-mons/#removing-monitors" target="_blank" rel="external">官方文档</a></p>
<h4 id="增加-删除-OSDs"><a href="#增加-删除-OSDs" class="headerlink" title="增加/删除 OSDs"></a>增加/删除 OSDs</h4><h5 id="增加OSD"><a href="#增加OSD" class="headerlink" title="增加OSD"></a>增加OSD</h5><h5 id="删除OSD"><a href="#删除OSD" class="headerlink" title="删除OSD"></a>删除OSD</h5><p>在删除OSD之前，OSD通常为up且in的状态，需要先将要删除的OSD踢出集群，让集群可以进行rebalancing，同时将数据拷贝到其它OSD上。 在<strong>管理节点</strong>执行OSD踢出集群命令如下：</p>
<pre><code>ceph osd out {osd-num}
#for example
ceph osd out 2
</code></pre><p>一旦OSD被踢出集群后，集群通过将要删除的OSD上的PGs迁出来进行rebalancing，我们可以通过如下命令来观察整个过程</p>
<pre><code>ceph -w
</code></pre><blockquote>
<p><strong>注意</strong>：在只有少数服务器的小集群中，比如我们测试的集群，在进行out操作可能使一些PGs始终在active+remapped状态，这时，应该将osd置回in,回到初始状态<br><code>ceph osd in {osd-num}</code><br>然后，不是out OSD，而是将OSD权重设置为0。<br><code>ceph osd crush reweight osd.{osd-num} 0</code><br>之后再观察数据迁移状态。out和权重置0的区别在于，第一种情况下，OSD权重不改变，后者桶的权重被更新。</p>
</blockquote>
<p>将OSD踢出集群后，OSD可能仍然处于up且out状态，在从配置中删除OSD之前，需要将该OSD服务停止，登录<strong>OSD节点</strong>，执行命令停止相关OSD服务</p>
<pre><code>ssh {osd-host}
sudo systemctl stop ceph-osd@{osd-num}
#for example
ssh ch-osd-1
systemctl stop ceph-osd@2
</code></pre><p>或者</p>
<pre><code>kill -9 {pid}
</code></pre><p>在早期的版本中使用如下命令</p>
<pre><code>service ceph stop osd.2
</code></pre><p>最后需要将OSD从集群的CRUSH MAP中删除，同时删除其权限，并且从OSD MAP删除OSD，在<strong>管理节点</strong>执行命令：</p>
<pre><code>#remove osd from crush map
ceph osd crush remove {name}
#remove the osd authentication key
ceph auth del osd.{osd-num}
#remove the osd
ceph osd rm {osd-num}
#for example
ceph osd crush remove osd.2
ceph auth del osd.2
ceph osd rm 2
</code></pre><p>如果在ceph.conf文件中有该OSD的配置，还需要删除相关配置</p>
<p>更详细的使用方法见<a href="http://docs.ceph.com/docs/master/rados/operations/add-or-rm-osds/#removing-osds-manual" target="_blank" rel="external">官方文档</a></p>
<h4 id="配置推送"><a href="#配置推送" class="headerlink" title="配置推送"></a>配置推送</h4><p>我们无需再每台服务器上修改ceph.conf文件中的配置信息，只需要在管理节点修改一份，然后推送到需要更行的节点上即可，如这里我们修改了ch-mon-1上/etc/ceph/ceph.conf内容，需要同时在ch-mon-2, ch-mon-3生效</p>
<pre><code>ceph-deploy --overwrite-conf config push ch-mon-2 ch-mon-3
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;原创申明&lt;/strong&gt;：本文为博主原创，转载请注明出处！    &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这篇文档主要介绍ceph的搭建过程。&lt;/p&gt;
&lt;h3 id=&quot;集群规划&quot;&gt;&lt;a href=&quot;#集群规划&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
      <category term="分布式存储" scheme="http://202.104.112.179:8085/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="运维操作" scheme="http://202.104.112.179:8085/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/"/>
    
      <category term="Ceph" scheme="http://202.104.112.179:8085/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/Ceph/"/>
    
    
      <category term="ceph" scheme="http://202.104.112.179:8085/tags/ceph/"/>
    
      <category term="分布式存储" scheme="http://202.104.112.179:8085/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希算法</title>
    <link href="http://202.104.112.179:8085/2017/07/29/consistHash/"/>
    <id>http://202.104.112.179:8085/2017/07/29/consistHash/</id>
    <published>2017-07-29T05:10:02.000Z</published>
    <updated>2017-08-10T11:12:12.859Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><strong>转载申明</strong>：本文转载博主<a href="http://weibo.com/oilbeater/profile?s=6cm7D0" target="_blank" rel="external">oilbeater</a>的文章<a href="http://oilbeater.com/%E5%8D%9A%E5%AE%A2/2016/12/18/consist-hash.html" target="_blank" rel="external">聊聊一致性哈希</a>，转载请注明出处！</p>
<hr>
<p>既然有一致性哈希，就肯定还有不一致哈希，为啥平时没人说不一致哈希呢？因为常见的哈希都是不一致的，所以就不修饰了，到了一致性哈希才特殊加个描述词修饰一下。</p>
<p>哈希一般都是将一个大数字取模然后分散到不同的桶里，假设我们只有两个桶，有 2、3、4、5 四个数字，那么模 2 分桶的结果就是：</p>
<img src="/2017/07/29/consistHash/unconsist-hash-1.png" alt="unconsist-hash-1.png" title="">
<p>这时我们嫌桶太少要给哈希表扩容加了一个新桶，这时候所有的数字就需要模 3 来确定分在哪个桶里，结果就变成了：</p>
<img src="/2017/07/29/consistHash/unconsist-hash-2.png" alt="unconsist-hash-2.png" title="">
<p>可以看到新加了一个桶后所有数字的分布都变了，这就意味着哈希表的每次扩展和收缩都会导致所有条目分布的重新计算，这个特性在某些场景下是不可接受的。比如分布式的存储系统，每个桶就相当于一个机器，文件分布在哪台机器由哈希算法来决定，这个系统想要加一台机器时就需要停下来等所有文件重新分布一次才能对外提供服务，而当一台机器掉线的时候尽管只掉了一部分数据，但所有数据访问路由都会出问题。这样整个服务就无法平滑的扩缩容，成为了有状态的服务。</p>
<p>要想实现无状态化，就要用到一致性哈希了，一致性哈希中假想我们有很多个桶，先定一个小目标比如 7 个，但一开始真实还是只有两个桶，编号是 3 和 6。哈希算法还是同样的取模，只不过现在分桶分到的很可能是不存在的桶，那么就往下找找到第一个真实存在的桶放进去。这样 2 和 3 都被分到了编号为 3 的桶， 4 和 5 被分到了编号为 6 的桶。</p>
<img src="/2017/07/29/consistHash/consist-hash-1.png" alt="consist-hash-1.png" title="">
<p>这时候再添加一个新的桶，编号是 4，取模方法不变还是模 7：</p>
<img src="/2017/07/29/consistHash/consist-hash-2.png" alt="consist-hash-2.png" title="">
<p>因为 3 号桶里都是取模小于等于 3 的，4 号桶只需要从 6 号桶里拿走属于它的数字就可以了，这种情况下只需要调整一个桶的数字就可分成了重新分布。可以想象下即使有 1 亿个桶，增加减少一个桶也只会影响一个桶的数据分布。</p>
<p>这样增加一个机器只需要和他后面的机器同步一下数据就可以开始工作了，下线一个机器需要先把他的数据同步到后面一台机器再下线。如果突然掉了一台机器也只会影响这台机器上的数据。实现中可以让每台机器同步一份自己前面机器的数据，这样即使掉线也不会影响这一部分的数据服务。</p>
<p>这里还有个小问题要是编号为 6 的机桶下线了，它没有后一个桶了，数据该咋办？为了解决这个问题，实现上通常把哈希空间做成环状，这样 3 就成了 6 的下一桶，数据给 3 就好了：</p>
<img src="/2017/07/29/consistHash/consist-hash-3.png" alt="consist-hash-3.png" title="">
<p>用一致性哈希还能实现部分的分布式系统无锁化，每个任务有自己的编号，由于哈希算法的确定性，分到哪个桶也是确定的就不存在争抢，也就不需要分布式锁了。</p>
<p>既然一致性哈希有这么多好的特性，那为啥主流的哈希都是非一致的呢？主要一个原因在于查找效率上，普通的哈希查询一次哈希计算就可以找到对应的桶了，算法时间复杂度是 O(1)，而一致性哈希需要将排好序的桶组成一个链表，然后一路找下去，k 个桶查询时间复杂度是 O(k)，所以通常情况下的哈希还是用不一致的实现。</p>
<p>当然 O(k) 的时间复杂度对于哈希来说还是不能忍的，想一下都是O(k) 这个量级了用哈希的意义在哪里？既然是在排好序的桶里查询，很自然的想法就是二分了，能把时间复杂度降到 O(logk)，然而桶的组合需要不断的增减，所以是个链表的实现，二分肯定就不行了，还好可以用跳转表进行一个快速的跳转也能实现 O(logk) 的时间复杂度。</p>
<img src="/2017/07/29/consistHash/finger-table.png" alt="finger-table.png" title="">
<p>在这个跳转表中，每个桶记录距离自己 1，2，4 距离的数字所存的桶，这样不管查询落在哪个节点上，对整个哈希环上任意的查询一次都可以至少跳过一半的查询空间，这样递归下去很快就可以定位到数据是存在哪个桶上。</p>
<p>当然这写都只是一致性哈希实现方式中的一种，还有很多实现上的变体。比如选择数字放在哪个桶，上面的介绍里是选择顺着数字下去出现的第一个桶，其实也可以选择距离这个数字最近的桶，这样实现和后面的跳转表规则也会有变化。同样跳转表也有多种不同的算法实现，感兴趣的可以去看一下 CAN，Chord，Tapestry，Pastry 这四种 DHT 的实现，有意思的是它们都是 2001 年发出来的 paper，所以 2001 年大概是 P2P 下载的元年吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;转载申明&lt;/strong&gt;：本文转载博主&lt;a href=&quot;http://weibo.com/oilbeater/profile?s=6cm7D0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;oilbeater&lt;/a&gt;的文章&lt;a 
    
    </summary>
    
      <category term="转载" scheme="http://202.104.112.179:8085/categories/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="技术原理" scheme="http://202.104.112.179:8085/categories/%E8%BD%AC%E8%BD%BD/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="算法" scheme="http://202.104.112.179:8085/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希" scheme="http://202.104.112.179:8085/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="分布式" scheme="http://202.104.112.179:8085/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
